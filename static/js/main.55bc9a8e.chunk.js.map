{"version":3,"sources":["common/services/geolocation.service.ts","nws/services/nws.service.ts","common/services/localStorage.service.ts","dashboard/reducers/forecast-reducer.ts","common/hooks/use-serialize-value.tsx","dashboard/components/menu.tsx","dashboard/pages/dashboard.styles.tsx","dashboard/utils/temperature.utils.ts","dashboard/components/hourly-forecast-grid-list-item.styles.tsx","dashboard/components/hourly-forecast-grid-list-tile.tsx","dashboard/components/hourly-forecast-grid-list.styles.tsx","dashboard/components/hourly-forecast-grid-list.tsx","dashboard/components/weather-card.tsx","dashboard/pages/hourly-forecast.page.tsx","dashboard/pages/dashboard.page.tsx","common/hooks/use-network-status.tsx","App.tsx","serviceWorkerRegistration.ts","reportWebVitals.ts","index.tsx"],"names":["geolocationService","getCurrentPosition","Promise","res","rej","navigator","geolocation","nwsService","apiClient","latitude","longitude","a","this","get","data","wfo","x","y","stationId","queryParams","params","axios","create","baseURL","headers","Accept","localStorageService","setItem","key","value","localStorage","JSON","stringify","getItem","parse","forecastReducer","state","action","type","payload","useSerializeValue","useEffect","Menu","open","anchorEl","anchorOrigin","onClose","onRefreshClicked","MenuItem","onClick","useStyles","makeStyles","theme","root","height","display","flexDirection","spacer","flexGrow","main","overflowY","hourlyForecastTab","gap","spacing","bottomNavigation","borderTop","borderColor","palette","divider","format","unit","alignItems","HourlyForecastGridListTile","temperature","temperatureUnit","time","icon","classes","className","Typography","toLocaleTimeString","src","alt","variant","temperatureUtils","gridList","gridAutoFlow","justifyItems","gridListContainer","overflowX","paddingLeft","paddingRight","minWidth","HourlyForecastGridList","periods","Card","CardContent","map","index","startTime","Date","length","Divider","orientation","WeatherCard","shortForecast","updateTime","station","Box","justifyContent","toLocaleString","HourlyForecastPage","currentWeather","hourlyForecast","initializeForecastState","location","city","forecast","observation","getPointInfo","properties","relativeLocation","gridId","gridX","gridY","getForecast","forecastRes","getHourlyForecast","hourlyForecastRes","getStations","stationsRes","features","stationIdentifier","getStationObservations","limit","observationRes","DashboardPage","isOnline","useState","window","onLine","setIsOnline","setOffline","setOnline","addEventListener","removeEventListener","useNetworkStatus","loading","setLoading","useReducer","undefined","forecastState","forecastStateDispatch","updateForecast","useCallback","then","finally","currentDate","endDate","setDate","getDate","setHours","currentHourlyPeriods","filter","endTime","menuAnchor","setMenuAnchor","activeTab","setActiveTab","TabContext","AppBar","position","Toolbar","IconButton","color","coords","MyLocation","edge","e","currentTarget","MoreVert","Boolean","LinearProgress","TabPanel","timestamp","textDescription","BottomNavigation","onChange","showLabels","BottomNavigationAction","Schedule","label","CalendarToday","App","hostname","match","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.55bc9a8e.chunk.js","sourcesContent":["/**\n * Wraps `navigator.geolocation.getCurrentPosition()` in a Promise.\n */\nfunction getCurrentPosition(): Promise<GeolocationPosition> {\n  return new Promise<GeolocationPosition>((res, rej) =>\n    navigator.geolocation.getCurrentPosition(res, rej)\n  );\n}\n\n/**\n * Provides convenience wrappers for function of `navigator.geolocation`.\n */\nconst geolocationService = {\n  getCurrentPosition,\n};\n\nexport default geolocationService;\n","import axios, { AxiosInstance } from \"axios\";\nimport ForecastResponse from \"../interfaces/forecast-response\";\nimport PointInfo from \"../interfaces/point-info\";\nimport StationObservationsResponse from \"../interfaces/station-observations-response\";\nimport StationsResponse from \"../interfaces/stations-response\";\n\nclass NWSService {\n  constructor(private apiClient: AxiosInstance) {}\n\n  async getPointInfo(latitude: number, longitude: number): Promise<PointInfo> {\n    return (await this.apiClient.get(`/points/${latitude},${longitude}`)).data;\n  }\n\n  async getForecast({\n    wfo,\n    x,\n    y,\n  }: GridPointsParams): Promise<ForecastResponse> {\n    return (await this.apiClient.get(`/gridpoints/${wfo}/${x},${y}/forecast`))\n      .data;\n  }\n\n  async getHourlyForecast({\n    wfo,\n    x,\n    y,\n  }: GridPointsParams): Promise<ForecastResponse> {\n    return (\n      await this.apiClient.get(`/gridpoints/${wfo}/${x},${y}/forecast/hourly`)\n    ).data;\n  }\n\n  async getStations({\n    wfo,\n    x,\n    y,\n  }: GridPointsParams): Promise<StationsResponse> {\n    return (await this.apiClient.get(`/gridpoints/${wfo}/${x},${y}/stations`))\n      .data;\n  }\n\n  async getStationObservations({\n    stationId,\n    ...queryParams\n  }: GetStationObservationsParams): Promise<StationObservationsResponse> {\n    return (\n      await this.apiClient.get(`/stations/${stationId}/observations`, {\n        params: queryParams,\n      })\n    ).data;\n  }\n}\n\ninterface GetStationObservationsParams {\n  stationId: string;\n  station?: string[];\n  start?: string;\n  end?: string;\n  limit?: number;\n}\n\ninterface GridPointsParams {\n  wfo: string;\n  x: number;\n  y: number;\n}\n\nconst nwsService = new NWSService(\n  axios.create({\n    baseURL: \"https://api.weather.gov\",\n    headers: { Accept: \"application/geo+json\" },\n  })\n);\n\nexport default nwsService;\n","/**\n * Calls `localStorage.setItem()` with `key` and the result of calling\n * `JSON.stringify()` with `value` for `value`.\n */\nfunction setItem(key: string, value: any) {\n  localStorage.setItem(key, JSON.stringify(value));\n}\n\n/**\n * Calls `localStorage.getItem()` with `key`. If the result is `null`, it gets\n * returned. Otherwise, the result of calling `JSON.parse()` with the value is\n * returned.\n */\nfunction getItem(key: string): any | null {\n  const value = localStorage.getItem(key);\n  if (value === null) {\n    return null;\n  }\n  return JSON.parse(value);\n}\n\n/**\n * Provides convenience wrappers for functions of `localStorage`.\n */\nconst localStorageService = {\n  setItem,\n  getItem,\n};\n\nexport default localStorageService;\n","import ForecastState from \"../interfaces/forecast-state\";\n\ntype Action = { type: \"updateForecast\"; payload: Partial<ForecastState> };\n\nexport default function forecastReducer(\n  state: ForecastState,\n  action: Action\n): ForecastState {\n  switch (action.type) {\n    case \"updateForecast\":\n      return { ...state, ...action.payload };\n  }\n}\n","import { useEffect } from \"react\";\nimport localStorageService from \"../services/localStorage.service\";\n\n/**\n * Writes a value to localStorage whenever the value changes.\n *\n * @param key - The key in localStorage to use\n * @param value - The value to store in localStorage\n */\nexport default function useSerializeValue(key: string, value: any) {\n  useEffect(() => {\n    localStorageService.setItem(key, value);\n  }, [key, value]);\n}\n","import {\n  Menu as MuiMenu,\n  MenuProps as MuiMenuProps,\n  MenuItem,\n} from \"@material-ui/core\";\n\ninterface MenuProps {\n  open?: boolean;\n  anchorEl?: MuiMenuProps[\"anchorEl\"];\n  anchorOrigin?: MuiMenuProps[\"anchorOrigin\"];\n  onClose?: MuiMenuProps[\"onClose\"];\n  onRefreshClicked?: () => void;\n}\n\nexport default function Menu({\n  open = false,\n  anchorEl,\n  anchorOrigin,\n  onClose,\n  onRefreshClicked,\n}: MenuProps) {\n  return (\n    <MuiMenu\n      open={open}\n      anchorEl={anchorEl}\n      anchorOrigin={anchorOrigin}\n      onClose={onClose}\n    >\n      <MenuItem onClick={onRefreshClicked}>Refresh</MenuItem>\n    </MuiMenu>\n  );\n}\n","import { makeStyles } from \"@material-ui/core\";\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    height: \"100%\",\n    display: \"flex\",\n    flexDirection: \"column\",\n  },\n  spacer: {\n    flexGrow: 1,\n  },\n  main: {\n    overflowY: \"auto\",\n    flexGrow: 1,\n  },\n  hourlyForecastTab: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    gap: theme.spacing(1),\n  },\n  bottomNavigation: {\n    borderTop: \"1px solid\",\n    borderColor: theme.palette.divider\n  },\n}));\n\nexport default useStyles;\n","/**\n * Returns a formatted temperature string.\n *\n * @param value - The temperature sans unit\n * @param unit - The unit\n * @returns The temperature formatted as a string\n */\nexport function format(value: number, unit: string): string {\n  switch (unit) {\n    case \"F\":\n      return `${value}℉`;\n    case \"C\":\n      return `${value}℃`;\n    case \"K\":\n      return `${value}K`;\n    default:\n      return `${value}`;\n  }\n}\n","import { makeStyles } from \"@material-ui/core\";\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    gap: theme.spacing(1),\n  },\n}));\n\nexport default useStyles;\n","import { Typography } from \"@material-ui/core\";\nimport * as temperatureUtils from \"../utils/temperature.utils\";\nimport useStyles from \"./hourly-forecast-grid-list-item.styles\";\n\ninterface HourlyForecastGridListTileProps {\n  temperature: number;\n  temperatureUnit: string;\n  time: Date;\n  icon: string;\n}\n\nexport default function HourlyForecastGridListTile({\n  temperature,\n  temperatureUnit,\n  time,\n  icon,\n}: HourlyForecastGridListTileProps) {\n  const classes = useStyles();\n  return (\n    <div className={classes.root}>\n      <Typography>{time.toLocaleTimeString()}</Typography>\n      <img src={icon} alt=\"\" />\n      <Typography variant=\"h6\">\n        {temperatureUtils.format(temperature, temperatureUnit)}\n      </Typography>\n    </div>\n  );\n}\n","import { makeStyles } from \"@material-ui/core\";\n\nconst useStyles = makeStyles((theme) => ({\n  gridList: {\n    display: \"grid\",\n    gridAutoFlow: \"column\",\n    justifyItems: \"center\",\n    gap: theme.spacing(4),\n  },\n  gridListContainer: {\n    display: \"flex\",\n    overflowX: \"auto\",\n    paddingLeft: 0,\n    paddingRight: 0,\n  },\n  spacer: {\n    display: \"inline-block\",\n    minWidth: theme.spacing(4),\n  },\n}));\n\nexport default useStyles;\n","import { Card, CardContent, Divider } from \"@material-ui/core\";\nimport { Fragment } from \"react\";\nimport { Period } from \"../../nws/interfaces/forecast-response\";\nimport HourlyForecastGridListTile from \"./hourly-forecast-grid-list-tile\";\nimport useStyles from \"./hourly-forecast-grid-list.styles\";\n\ninterface HourlyForecastGridListProps {\n  periods: Period[];\n}\n\nexport default function HourlyForecastGridList({\n  periods,\n}: HourlyForecastGridListProps) {\n  const classes = useStyles();\n  return (\n    <Card>\n      <CardContent className={classes.gridListContainer}>\n        {/*\n         * Maintain consistent spacing between tile and edge and tile and\n         * divider.\n         */}\n        <div className={classes.spacer} />\n        <div className={classes.gridList}>\n          {periods.map(\n            (\n              { temperature, temperatureUnit, startTime: time, icon },\n              index\n            ) => (\n              <Fragment key={time}>\n                <HourlyForecastGridListTile\n                  temperature={temperature}\n                  temperatureUnit={temperatureUnit}\n                  time={new Date(time)}\n                  icon={icon}\n                />\n                {index !== periods.length - 1 && (\n                  <Divider orientation=\"vertical\" />\n                )}\n              </Fragment>\n            )\n          )}\n        </div>\n        <div className={classes.spacer} />\n      </CardContent>\n    </Card>\n  );\n}\n","import { Box, Card, CardContent, Typography } from \"@material-ui/core\";\nimport * as temperatureUtils from \"../utils/temperature.utils\";\n\nexport interface WeatherCardProps {\n  icon: string;\n  shortForecast: string;\n  temperature: number;\n  temperatureUnit: string;\n  updateTime?: Date;\n  station?: string;\n}\n\nexport default function WeatherCard({\n  icon,\n  shortForecast,\n  temperature,\n  temperatureUnit,\n  updateTime,\n  station,\n}: WeatherCardProps) {\n  return (\n    <Card>\n      <CardContent>\n        <Typography variant=\"h5\">{shortForecast}</Typography>\n        <Box display=\"flex\" justifyContent=\"space-between\" alignItems=\"center\">\n          <img alt=\"\" src={icon} />\n          <Typography variant=\"h3\">\n            {temperatureUtils.format(temperature, temperatureUnit)}\n          </Typography>\n        </Box>\n        {updateTime && (\n          <Box display=\"flex\" justifyContent=\"flex-end\">\n            <Typography variant=\"caption\">\n              {updateTime.toLocaleString()}\n            </Typography>\n          </Box>\n        )}\n        {updateTime && (\n          <Box display=\"flex\" justifyContent=\"flex-end\">\n            <Typography variant=\"caption\">\n              {station}\n            </Typography>\n          </Box>\n        )}\n      </CardContent>\n    </Card>\n  );\n}\n","import { Period } from \"../../nws/interfaces/forecast-response\";\nimport HourlyForecastGridList from \"../components/hourly-forecast-grid-list\";\nimport WeatherCard, { WeatherCardProps } from \"../components/weather-card\";\n\ninterface HourlyForecastPageProps {\n  currentWeather: WeatherCardProps;\n  hourlyForecast: Period[];\n  updateTime: Date;\n  station: string;\n}\n\nexport default function HourlyForecastPage({\n  currentWeather,\n  hourlyForecast,\n  updateTime,\n  station,\n}: HourlyForecastPageProps) {\n  return (\n    <>\n      <WeatherCard\n        icon={currentWeather.icon}\n        shortForecast={currentWeather.shortForecast}\n        temperature={currentWeather.temperature}\n        temperatureUnit={currentWeather.temperatureUnit}\n        updateTime={updateTime}\n        station={station}\n      />\n      <HourlyForecastGridList periods={hourlyForecast} />\n    </>\n  );\n}\n","import { useCallback, useEffect, useReducer, useState } from \"react\";\nimport {\n  AppBar,\n  BottomNavigation,\n  BottomNavigationAction,\n  Box,\n  IconButton,\n  LinearProgress,\n  Toolbar,\n  Typography,\n} from \"@material-ui/core\";\nimport {\n  MoreVert as MoreVertIcon,\n  MyLocation as MyLocationIcon,\n  Schedule as ScheduleIcon,\n  CalendarToday as CalendarTodayIcon,\n} from \"@material-ui/icons\";\nimport { TabContext, TabPanel } from \"@material-ui/lab\";\nimport geolocationService from \"../../common/services/geolocation.service\";\nimport nwsService from \"../../nws/services/nws.service\";\nimport localStorageService from \"../../common/services/localStorage.service\";\nimport useNetworkStatus from \"../../common/hooks/use-network-status\";\nimport forecastReducer from \"../reducers/forecast-reducer\";\nimport ForecastState from \"../interfaces/forecast-state\";\nimport useSerializeValue from \"../../common/hooks/use-serialize-value\";\nimport Menu from \"../components/menu\";\nimport Coordinates from \"../../common/interfaces/coordinates\";\nimport useStyles from \"./dashboard.styles\";\nimport HourlyForecastPage from \"./hourly-forecast.page\";\n\nfunction initializeForecastState(): ForecastState {\n  return {\n    location: localStorageService.getItem(\"location\"),\n    city: localStorageService.getItem(\"city\"),\n    state: localStorageService.getItem(\"state\"),\n    forecast: localStorageService.getItem(\"forecast\"),\n    hourlyForecast: localStorageService.getItem(\"hourlyForecast\"),\n    stationId: localStorageService.getItem(\"stationId\"),\n    observation: localStorageService.getItem(\"observation\"),\n  };\n}\n\n/**\n * Returns a new `ForecastState` based on `location`.\n *\n * @param location - The location to get the forecast for\n * @returns A `Promise` for the new `ForecastState`\n */\nasync function getForecast(location: Coordinates): Promise<ForecastState> {\n  const {\n    properties: {\n      relativeLocation: {\n        properties: { city, state },\n      },\n      gridId: wfo,\n      gridX: x,\n      gridY: y,\n    },\n  } = await nwsService.getPointInfo(location.latitude, location.longitude);\n  const forecastRes = await nwsService.getForecast({ wfo, x, y });\n  const hourlyForecastRes = await nwsService.getHourlyForecast({\n    wfo,\n    x,\n    y,\n  });\n  const stationsRes = await nwsService.getStations({ wfo, x, y });\n  const stationId = stationsRes.features[0].properties.stationIdentifier;\n  const observationRes = await nwsService.getStationObservations({\n    stationId,\n    limit: 1, // Only get the most recent observation\n  });\n  return {\n    location,\n    city,\n    state,\n    forecast: forecastRes,\n    hourlyForecast: hourlyForecastRes,\n    stationId,\n    observation: observationRes,\n  };\n}\n\nexport default function DashboardPage() {\n  const classes = useStyles();\n  const isOnline = useNetworkStatus();\n  const [loading, setLoading] = useState(false);\n  const [forecastState, forecastStateDispatch] = useReducer(\n    forecastReducer,\n    undefined,\n    initializeForecastState\n  );\n\n  const {\n    location,\n    city,\n    state,\n    forecast,\n    hourlyForecast,\n    observation,\n    stationId,\n  } = forecastState;\n\n  const currentWeather = observation?.features[0].properties ?? null;\n\n  const updateForecast = useCallback((location: Coordinates) => {\n    setLoading(true);\n    getForecast(location)\n      .then((state) =>\n        forecastStateDispatch({ type: \"updateForecast\", payload: state })\n      )\n      .finally(() => setLoading(false));\n  }, []);\n\n  // Fetch forecast data when the location gets updated\n  useEffect(() => {\n    if (!location || !isOnline) {\n      return;\n    }\n    updateForecast(location);\n  }, [isOnline, location, updateForecast]);\n\n  // Save information about the last location and forecast retrieved so it can\n  // be used after the application has been closed\n  useSerializeValue(\"location\", location);\n  useSerializeValue(\"city\", city);\n  useSerializeValue(\"state\", state);\n  useSerializeValue(\"forecast\", forecast);\n  useSerializeValue(\"hourlyForecast\", hourlyForecast);\n  useSerializeValue(\"forecastState\", forecastState);\n  useSerializeValue(\"station\", stationId);\n  useSerializeValue(\"observation\", observation);\n\n  const currentDate = new Date();\n  const endDate = new Date(currentDate);\n  endDate.setDate(endDate.getDate() + 1);\n  endDate.setHours(0, 0, 0, 0);\n  const currentHourlyPeriods = hourlyForecast?.properties.periods.filter(\n    ({ endTime, startTime }) =>\n      new Date(endTime) > currentDate && new Date(startTime) < endDate\n  );\n\n  const updateLocation = () => {\n    geolocationService.getCurrentPosition().then(({ coords }) => {\n      forecastStateDispatch({\n        type: \"updateForecast\",\n        payload: {\n          location: { latitude: coords.latitude, longitude: coords.longitude },\n        },\n      });\n    });\n  };\n\n  const [menuAnchor, setMenuAnchor] = useState<null | HTMLElement>(null);\n\n  const [activeTab, setActiveTab] = useState(\"hourly\");\n\n  return (\n    <div className={classes.root}>\n      <TabContext value={activeTab}>\n        <AppBar position=\"sticky\">\n          <Toolbar>\n            <Typography variant=\"h6\">\n              {city || state\n                ? `${city ?? \"Unknown\"}, ${state ?? \"Unknown\"}`\n                : \"Unknown\"}\n            </Typography>\n            <IconButton color=\"inherit\" onClick={updateLocation}>\n              <MyLocationIcon />\n            </IconButton>\n            <Box className={classes.spacer} />\n            <IconButton\n              color=\"inherit\"\n              edge=\"end\"\n              onClick={(e) => setMenuAnchor(e.currentTarget)}\n            >\n              <MoreVertIcon />\n            </IconButton>\n          </Toolbar>\n        </AppBar>\n        <Menu\n          anchorEl={menuAnchor}\n          open={Boolean(menuAnchor)}\n          onClose={() => setMenuAnchor(null)}\n          onRefreshClicked={() => {\n            setMenuAnchor(null);\n            if (!location || !isOnline) {\n              return;\n            }\n            updateForecast(location);\n          }}\n        />\n        {loading && <LinearProgress color=\"secondary\" />}\n        <main className={classes.main}>\n          <TabPanel value=\"hourly\" className={classes.hourlyForecastTab}>\n            {currentWeather && currentHourlyPeriods?.length && (\n              <HourlyForecastPage\n                updateTime={new Date(currentWeather.timestamp)}\n                station={stationId ?? \"\"}\n                currentWeather={{\n                  icon: currentWeather.icon,\n                  shortForecast: currentWeather.textDescription,\n                  temperature: currentWeather.temperature.value ?? 0,\n                  temperatureUnit: \"C\",\n                  updateTime: new Date(currentWeather.timestamp),\n                  station: stationId ?? \"\",\n                }}\n                hourlyForecast={currentHourlyPeriods}\n              />\n            )}\n          </TabPanel>\n          <TabPanel value=\"daily\"></TabPanel>\n        </main>\n        <BottomNavigation\n          value={activeTab}\n          onChange={(e, value) => setActiveTab(value)}\n          showLabels\n          className={classes.bottomNavigation}\n        >\n          <BottomNavigationAction icon={<ScheduleIcon />} label=\"Hourly\" value=\"hourly\" />\n          <BottomNavigationAction icon={<CalendarTodayIcon />} label=\"Daily\" value=\"daily\" />\n        </BottomNavigation>\n      </TabContext>\n    </div>\n  );\n}\n","import { useEffect, useState } from \"react\";\n\n/**\n * Returns the browser's online status.\n */\nexport default function useNetworkStatus() {\n  const [isOnline, setIsOnline] = useState(window.navigator.onLine);\n  useEffect(() => {\n    function setOffline() {\n      setIsOnline(false);\n    }\n    function setOnline() {\n      setIsOnline(true);\n    }\n    window.addEventListener(\"offline\", setOffline);\n    window.addEventListener(\"online\", setOnline);\n\n    return () => {\n      window.removeEventListener(\"offline\", setOffline);\n      window.removeEventListener(\"online\", setOnline);\n    };\n  }, []);\n\n  return isOnline;\n}\n","import \"./App.css\";\nimport DashboardPage from \"./dashboard/pages/dashboard.page\";\n\nexport default function App() {\n  return (\n    <div className=\"App\">\n      <DashboardPage />\n    </div>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://cra.link/PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://cra.link/PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import { ReportHandler } from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorkerRegistration from \"./serviceWorkerRegistration\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.unregister();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}